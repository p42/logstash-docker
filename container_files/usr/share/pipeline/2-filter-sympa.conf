filter {
    if [program] =~ /^sympa/ and "csv" not in [tags]{
        mutate{
            add_tag => [ "SympaLog" ]
        }
        # Determine if there is a function.
        grok {
            patterns_dir   => "/usr/share/logstash/patterns"
            match          => { "message" => "%{SYMPA_FUNCTION:function}"}
            add_tag        => ["sympa_function"]
            tag_on_failure => [ "_sympa_no_function" ]
        }
        if "sympa_function" in [tags] and [function] == "DoFile()"{
             grok {
                 patterns_dir   => "/usr/share/logstash/patterns"
#                match          => { "message" => "%{SYMPA_DO_FILE}"}
                match          => [ "message", "%{LOGLEVEL:log_level} %{SCOPED_FUNCTION_CALL:scoped_function} %{WORD:action} %{UNIXPATH:path} ; ([a-z]*:) %{EMAILADDRESS:email}\s\W%{PROCESSWORKER:process} ; ([\w-]+): \W%{SYMPA_MESSAGE_ID:message_id}" ]
                 tag_on_failure => [ "_sympa_do_file_nomatch" ]
                 add_tag        => [ "_sympa_do_file_success", "processed" ]
                 timeout_millis => 10000
                 tag_on_timeout => [ "_sympa_do_file_timeout" ]
             }
        }
        else if "sympa_function" in [tags] and [function] == "DoMessage()" {
            grok {
                patterns_dir    => "/usr/share/logstash/patterns"
                match           => {"message" => "%{SYMPA_DO_MESSAGE}"}
                tag_on_failure  => [ "_sympa_do_message_no_match" ]
                add_tag         => [ "_sympa_do_message", "processed" ]
                tag_on_timeout  => [ "_sympa_do_message_timeout" ]
                remove_field    => [ "function" ]
            }
        }
        else if "sympa_function" not in [tags] {
            grok {
                patterns_dir    => "/usr/share/logstash/patterns"
                match           => {"message" => "%{SYMPA_NO_FUNCTION}"}
                tag_on_failure  => [ "_sympa_no_function_no_match" ]
                add_tag         => [ "_sympa_no_function_grokked", "processed" ]
            }

        }
        mutate {
            remove_tag          => [ "sympa_function", "_sympa_do_message", "_sympa_no_function" ]
        }
    }
    else if [program] =~ /^bulk/ {
        mutate {
            add_tag             => [ "_bulk_program" ]
        }
        grok {
            break_on_match  => false
            patterns_dir    => "/usr/share/logstash/patterns"
            match           => {"message" => "%{BULK_LOG_MESSAGE}"}
            match           => {"log_message" => "%{BULK_MESSAGE_DETAILS}"}
            tag_on_failure  => [ "_bulk_parse_failure" ]
            add_tag         => ["processed", "bulk_program"]
        }
    }
    else if [program] =~ /^archived/ {
        grok {
            break_on_match  => false
            patterns_dir    => "/usr/share/logstash/patterns"
            match           => {"message" => "%{ARCHIVE_MESSAGE}"}
            tag_on_failure  => [ "_archived_parse_fail" ]
        }
        mutate {
            add_tag         => [ "_archived_program", "processed" ]
            replace         => {"log_message" => "%{action} %{log_message}"}
        }
    }
    else if [program] =~ /^task_manager/ {
        mutate {
            add_tag             => [ "_task_manager_program" ]
        }
        grok {
            break_on_match  => false
            patterns_dir    => "/usr/share/logstash/patterns"
            match           => {"message" => "%{TASK_MANAGER_FUNCTION}"}
            tag_on_failure  => [ "_task_manager_parse_fail" ]
            add_tag         => ["processed"]
        }
    }
}
