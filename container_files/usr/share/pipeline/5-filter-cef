filter {
    if [type] == "CEF" {
      # Manipulate the message
      mutate {
           # Saved the original message into a temporary field
           add_field => { "tmp_message" => "%{message}" }
           # splits message on the "|"  and has index numbers
           split => ["message", "|"]
           # generate fields for the CEF header
           add_field => { "cef_version" => "%{message[0]}" }
           add_field => { "cef_device_vendor" => "%{message[1]}" }
           add_field => { "cef_device_product" => "%{message[2]}" }
           add_field => { "cef_device_version" => "%{message[3]}" }
           add_field => { "cef_sig_id" => "%{message[4]}" }
           add_field => { "cef_sig_name" => "%{message[5]}" }
           add_field => { "cef_sig_severity" => "%{message[6]}" }
      }
      # Parse the message with field=value formats
      kv {
          # Note: values with spaces are lost (still getting there)
#           field_split => " "
           # Only included the fields which are of interest (dont need everything)
           include_keys => ["cat","act","proto","dst","dpt","src","spt"]
      }
      mutate {
          # Rename fields to cef_field_names
          rename => [ "cat",    "cef_traffic_category"]
          rename => [ "act",    "cef_traffic_action"]
          rename => [ "proto",  "cef_traffic_proto"]
          rename => [ "dst",    "cef_traffic_dst_ip"]
          rename => [ "dpt",    "cef_traffic_dst_port"]
          rename => [ "src",    "cef_traffic_src_ip"]
          rename => [ "spt",    "cef_traffic_src_port"]
          # Revert original message and remove temporary field
          replace => { "message" => "%{tmp_message}" }
          remove_field => [ "tmp_message" ]
      }
    }
}