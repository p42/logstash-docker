filter {
    # If the type is CEF, set it directly to that filter using tags.
    # Since nothing, so far, differentiates on type, leave that in place for 
    # potential future compatibility but keep with our working standard for now.
    if [message] =~ /CEF/ {
        mutate {
#            add_type    => ["CEF"]
        }
        grok {
            patterns_dir   => "/usr/share/logstash/patterns"
            match   =>{"message" => "%{FORTIDATE:date} %{NOTSPACE:device_hostname}%{GREEDYDATA:other_info},(?<message>%{GREEDYDATA})"}
            overwrite   => ["message"]
            add_tag     => ["cef"]
        }
    }
#    If it looks like a key/value pair %{WORD}=%{WORD}, try that.
    if [message] =~ /^\b\w+\b=\b\w+\b/ {
        kv {
            add_tag     => ["processed", "kv"]
        }
    }
    # Look for syslog info on the front of the message. Most of our logs will come in here.
    grok {
        match           => { "message" => "%{SYSLOGTIMESTAMP} %{SYSLOGHOST:host} %{DATA:program}(?:\[%{POSINT}\])?: %{GREEDYDATA:message}" }
        overwrite       => [ "message", "host" ]
        tag_on_failure  => ["_syslog_preprocess_fail"]
        add_tag         => ["_syslog_preprocess"]
    }
    #We only want to try csv parsing if it is from an input where we expect CSV format. Otherwise this 
    #causes unnecessary parse failures.
    if "csv" in [tags] {
        csv {
            columns         => ["Level","Date_and_Time","Source","Event ID","Task Category", "Log_Message"]
            add_tag         => ["csv","processed"]
        }
    }
}